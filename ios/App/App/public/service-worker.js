const s=location.pathname.split("/").slice(0,-1).join("/"),c=[s+"/_app/immutable/entry/app.BBg-deHd.js",s+"/_app/immutable/nodes/0.D4QYD_Cn.js",s+"/_app/immutable/assets/0.BXSW8Jwq.css",s+"/_app/immutable/nodes/1.CZE5zACm.js",s+"/_app/immutable/nodes/10.x3SBvtCy.js",s+"/_app/immutable/nodes/11.B6I-RMnb.js",s+"/_app/immutable/nodes/12.BhTzOFuy.js",s+"/_app/immutable/nodes/13.BPv50-0I.js",s+"/_app/immutable/nodes/14.CbkKuM2l.js",s+"/_app/immutable/nodes/15.DZhh9F92.js",s+"/_app/immutable/nodes/2.DG4d8Ix1.js",s+"/_app/immutable/assets/2.B_y7shiW.css",s+"/_app/immutable/nodes/3.DHMHhrbS.js",s+"/_app/immutable/nodes/4.Cm6BVKi6.js",s+"/_app/immutable/assets/4.CPHJG4w7.css",s+"/_app/immutable/nodes/5.Y9qzIzt_.js",s+"/_app/immutable/nodes/6.DBXlXLYD.js",s+"/_app/immutable/nodes/7.C5is1AuQ.js",s+"/_app/immutable/nodes/8.y9Xm5pIH.js",s+"/_app/immutable/nodes/9.DEyEU50U.js",s+"/_app/immutable/assets/page test component.BXdXTyR9.css",s+"/_app/immutable/chunks/4VTyHjO1.js",s+"/_app/immutable/chunks/B5HhpTuQ.js",s+"/_app/immutable/chunks/B5MxmZVD.js",s+"/_app/immutable/chunks/B6wTypnJ.js",s+"/_app/immutable/chunks/CSdGxEuB.js",s+"/_app/immutable/chunks/CaG2HxT3.js",s+"/_app/immutable/chunks/DLxvbaKY.js",s+"/_app/immutable/chunks/Di1hLUHM.js",s+"/_app/immutable/chunks/DkcoMD6F.js",s+"/_app/immutable/chunks/P9WnpAVd.js",s+"/_app/immutable/chunks/Pj-fetoB.js",s+"/_app/immutable/chunks/l2dRyl6z.js",s+"/_app/immutable/chunks/t3yHYGOu.js",s+"/_app/immutable/entry/start.COxAZy9b.js"],o=[s+"/apple-touch-icon-180x180.png",s+"/favicon.ico",s+"/generic.png",s+"/manifest.json",s+"/maskable-icon-512x512.png",s+"/Monytri-01-1.png",s+"/Property 1=Inbox.svg",s+"/pwa-192x192.png",s+"/pwa-512x512.png",s+"/pwa-64x64.png"],u="1743612991226";console.log({build:c,files:o,version:u});console.log("service worker is running");const l="Monytri-PWA",i=`${l}-cache-${u}`,r=[...c,...o];self.addEventListener("install",a=>{async function n(){await(await caches.open(i)).addAll(r)}a.waitUntil(n())});self.addEventListener("activate",a=>{async function n(){for(const t of await caches.keys())t.startsWith(l)&&t!==i&&await caches.delete(t)}a.waitUntil(n())});self.addEventListener("fetch",a=>{if(a.request.method!=="GET")return;async function n(){const t=new URL(a.request.url),p=await caches.open(i);if(r.includes(t.pathname)){const e=await p.match(t.pathname);if(e)return e}try{const e=await fetch(a.request);if(!(e instanceof Response))throw new Error("invalid response from fetch");return e.status===200&&p.put(a.request,e.clone()),e}catch(e){const m=await p.match(a.request);if(m)return m;throw e}}a.respondWith(n())});self.addEventListener("message",a=>{a.data&&a.data.type==="SKIP_WAITING"&&self.skipWaiting()});
